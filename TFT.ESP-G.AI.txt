#include <BluetoothSerial.h>
#include <WiFi.h>
#include <EEPROM.h>
#include <WebServer.h>
// üî• TFT ‡§î‡§∞ SD ‡§ï‡§æ‡§∞‡•ç‡§° ‡§ï‡•á ‡§≤‡§ø‡§è ‡§ú‡§º‡§∞‡•Ç‡§∞‡•Ä ‡§≤‡§æ‡§á‡§¨‡•ç‡§∞‡•á‡§∞‡•Ä (TFT and SD Card Libraries)
#include <SPI.h>
#include <SD.h>
#include <Adafruit_GFX.h>
#include <Adafruit_ILI9341.h>
// üî• TimeLib ‡§Ö‡§¨ ‡§ú‡§º‡§∞‡•Ç‡§∞‡•Ä ‡§®‡§π‡•Ä‡§Ç, ‡§π‡§Æ‡§®‡•á ‡§á‡§∏‡•á ‡§π‡§ü‡§æ ‡§¶‡§ø‡§Ø‡§æ ‡§π‡•à‡•§
// #include <TimeLib.h> 

BluetoothSerial SerialBT;
WebServer server(80);

// üî• TFT ‡§î‡§∞ SD ‡§ï‡§æ‡§∞‡•ç‡§° ‡§ï‡•á ‡§™‡§ø‡§®‡•ç‡§∏ (TFT and SD Card Pins)
#define TFT_CS    23
#define TFT_DC    22 
#define TFT_RST   -1    // ‡§Ü‡§™ -1 ‡§∞‡§ñ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç, ‡§Ø‡§æ ‡§á‡§∏‡•á GPIO 35 ‡§∏‡•á ‡§ú‡•ã‡§°‡§º ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç

#define SD_CS     13   // SD ‡§ï‡§æ‡§∞‡•ç‡§° Chip Select

// TFT ‡§ë‡§¨‡•ç‡§ú‡•á‡§ï‡•ç‡§ü (TFT Object)
Adafruit_ILI9341 tft = Adafruit_ILI9341(TFT_CS, TFT_DC, TFT_RST);
unsigned long lastTFTUpdate = 0;
// -----------------------------------------------------------------

// üî• ‡§ü‡§æ‡§á‡§Æ ‡§µ‡•á‡§∞‡§ø‡§è‡§¨‡§≤‡•ç‡§∏ (Time Variables) - ‡§®‡§Ø‡§æ
unsigned long lastSecond = 0;
int currentHour = 10;
int currentMinute = 0;
int currentSecond = 0;
// -----------------------------------------------------------------

// Motor Pins
const int MOTOR_IN1 = 5;
const int MOTOR_IN2 = 18;
unsigned long MOTOR_RUN_TIME = 8000; // default 8 sec
bool isMotorRunning = false;
unsigned long motorStartMillis = 0;
String currentDirection = "";
String lockState = "UNLOCKED";
bool isCharging = false; // ‡§ó‡•ç‡§≤‡•ã‡§¨‡§≤ ‡§ö‡§æ‡§∞‡•ç‡§ú‡§ø‡§Ç‡§ó ‡§∏‡•ç‡§ü‡•á‡§ü‡§∏

// LED Pins (‡§Ø‡•á ‡§Ö‡§¨ ‡§°‡§ø‡§∏‡•ç‡§™‡•ç‡§≤‡•á ‡§ï‡•Ä ‡§µ‡§ú‡§π ‡§∏‡•á ‡§ú‡§º‡§∞‡•Ç‡§∞‡•Ä ‡§®‡§π‡•Ä‡§Ç, ‡§™‡§∞ ‡§ï‡•ã‡§° ‡§Æ‡•á‡§Ç ‡§∞‡§π‡§®‡•á ‡§¶‡§ø‡§è)
const int LED_FORWARD = 2;
const int LED_BACKWARD = 4;
const int LED_SLEEP = 21;
const int LED_CHARGING = 15;
const int CHARGING_PIN = 34;

// Buttons, Buzzer, Security, EEPROM, Sleep, etc... (‡§¨‡§æ‡§ï‡•Ä ‡§∏‡§¨ ‡§µ‡•à‡§∏‡§æ ‡§π‡•Ä ‡§π‡•à)
const int LOCK_BUTTON = 32;
const int UNLOCK_BUTTON = 33;
int lastLockState = HIGH;
int lastUnlockState = HIGH;
const int BUZZER_PIN = 19;
char bluetoothPin[7] = "902736";
char wifiPassword[20] = "48364836";
char newBluetoothPin[7] = "";
char newWiFiPassword[20] = "";
const char* ssid = "SMART DOOR LOCK";
const int EEPROM_SIZE = 128;
const int EEPROM_ADDR_MOTOR_TIME = 0;
const int EEPROM_ADDR_BT_PIN = 8;
const int EEPROM_ADDR_WIFI_PIN = 32;
const int EEPROM_ADDR_LOCK_STATE = 60;
bool isSleepMode = false;
unsigned long lastActivityTime = 0;
const unsigned long SLEEP_TIMEOUT = 600000; // 10 min
unsigned long lastBlinkTime = 0;
bool previousChargingState = false;


// ---------------- Helper Functions -----------------
void beepBuzzer(int beeps){
  for(int i=0;i<beeps;i++){
    digitalWrite(BUZZER_PIN,HIGH);
    delay(100);
    digitalWrite(BUZZER_PIN,LOW);
    if(i<beeps-1) delay(100);
  }
}

// ---------------- Motor Functions -----------------
void startMotor(bool isLock){
  if(isMotorRunning) return;
  if(isLock && lockState=="LOCKED") return;
  if(!isLock && lockState=="UNLOCKED") return;

  if(isLock){
    digitalWrite(MOTOR_IN1,HIGH);
    digitalWrite(MOTOR_IN2,LOW);
    digitalWrite(LED_FORWARD,HIGH);
    digitalWrite(LED_BACKWARD,LOW);
    currentDirection="LOCK";
    lockState="TRANSITIONING";
  } else {
    digitalWrite(MOTOR_IN1,LOW);
    digitalWrite(MOTOR_IN2,HIGH);
    digitalWrite(LED_FORWARD,LOW);
    digitalWrite(LED_BACKWARD,HIGH);
    currentDirection="UNLOCK";
    lockState="TRANSITIONING";
  }

  motorStartMillis = millis();
  isMotorRunning=true;
}

void stopMotor(){
  digitalWrite(MOTOR_IN1,LOW);
  digitalWrite(MOTOR_IN2,LOW);
  digitalWrite(LED_FORWARD,LOW);
  digitalWrite(LED_BACKWARD,LOW);
  isMotorRunning=false;
  beepBuzzer(2);
  if(currentDirection=="LOCK"){
    lockState="LOCKED";
    EEPROM.write(EEPROM_ADDR_LOCK_STATE,1);
  } else {
    lockState="UNLOCKED";
    EEPROM.write(EEPROM_ADDR_LOCK_STATE,0);
  }
  EEPROM.commit();
}


// ---------------- Sleep / Charging -----------------
void updateSleepLED(){
  if(isSleepMode) digitalWrite(LED_SLEEP,HIGH);
  else {
    static unsigned long lastBlink=0;
    if(millis()-lastBlink>500){
      digitalWrite(LED_SLEEP,!digitalRead(LED_SLEEP));
      lastBlink=millis();
    }
  }
}

void checkCharging(){
  bool currentChargingState = digitalRead(CHARGING_PIN)==HIGH;
  if(currentChargingState != previousChargingState){
    previousChargingState = currentChargingState;
  }
  // üî• Global flag update
  isCharging = currentChargingState; 

  if(currentChargingState){
    if(millis()-lastBlinkTime>250){
      digitalWrite(LED_CHARGING,!digitalRead(LED_CHARGING));
      lastBlinkTime=millis();
    }
  } else {
    digitalWrite(LED_CHARGING,LOW);
  }
}

// ---------------- Web Interface -----------------
String webPageHtml(){
  String p="<html><head><meta name='viewport' content='width=device-width,initial-scale=1'>";
  p+="<title>Door Lock Control</title>";
  p+="<style>body{background:#111;color:#fff;font-family:Arial;text-align:center;padding:18px;} ";
  p+="h1{font-size:28px;margin:8px 0;} .btn{display:inline-block;padding:18px 28px;margin:10px;font-size:20px;border-radius:12px;border:none;color:#fff;cursor:pointer;} ";
  p+=".lock{background:#d32f2f;} .unlock{background:#2e7d32;} .syson{background:#0277bd;} .sysoff{background:#6d6d6d;} ";
  p+=".status{margin-top:20px;font-size:20px;} .small{font-size:14px;color:#aaa;margin-top:6px;} </style></head><body>";
  p+="<h1>Door Lock Control</h1>";
  p+="<div><button class='btn lock' onclick=\"fetch('/lock')\">LOCK</button>";
  p+="<button class='btn unlock' onclick=\"fetch('/unlock')\">UNLOCK</button></div>";
  p+="<div style='margin-top:12px;'><button class='btn syson' onclick=\"fetch('/system_on')\">SYSTEM ON</button>";
  p+="<button class='btn sysoff' onclick=\"fetch('/system_off')\">SYSTEM OFF</button></div>";
  p+="<div class='status'>Status: "+lockState+" | System: ON</div>";
  p+="<div class='small'>IP: 192.168.4.1 ‚Äî Connect to hotspot and open in Chrome</div>";
  p+="</body></html>";
  return p;
}

void handleRoot(){server.send(200,"text/html",webPageHtml());}
void handleLock(){startMotor(true);server.sendHeader("Location","/");server.send(303);}
void handleUnlock(){startMotor(false);server.sendHeader("Location","/");server.send(303);}
void handleSystemOn(){server.sendHeader("Location","/");server.send(303);}
void handleSystemOff(){server.sendHeader("Location","/");server.send(303);}


// ---------------- üî• TFT UPDATE FUNCTION üî• -----------------
void updateTFT() {
    // üî• ‡§®‡§Ø‡§æ ‡§ü‡§æ‡§á‡§Æ ‡§≤‡•â‡§ú‡§ø‡§ï üî•
    if (millis() - lastSecond >= 1000) {
      currentSecond++;
      if (currentSecond >= 60) {
        currentSecond = 0;
        currentMinute++;
        if (currentMinute >= 60) {
          currentMinute = 0;
          currentHour++;
          if (currentHour >= 24) {
            currentHour = 0;
          }
        }
      }
      lastSecond = millis();
    }
    
    // ‡§π‡§∞ 2 ‡§∏‡•á‡§ï‡§Ç‡§° ‡§Æ‡•á‡§Ç ‡§Ö‡§™‡§°‡•á‡§ü ‡§ï‡§∞‡•á‡§Ç, ‡§Ø‡§æ ‡§ú‡§¨ ‡§∏‡§Æ‡§Ø ‡§¨‡§¶‡§≤‡§§‡§æ ‡§π‡•à
    if (millis() - lastTFTUpdate < 2000 && (millis() - lastTFTUpdate > 1000) && currentSecond != 0) return; 

    tft.fillRect(0, 0, tft.width(), 40, ILI9341_BLACK); // ‡§ü‡•â‡§™ ‡§¨‡§æ‡§∞ ‡§∏‡§æ‡§´‡§º ‡§ï‡§∞‡•á‡§Ç

    // 1. ‡§≤‡•â‡§ï/‡§Ö‡§®‡§≤‡•â‡§ï ‡§∏‡•ç‡§ü‡•á‡§ü‡§∏ (Lock/Unlock Status)
    tft.fillRect(0, 40, tft.width(), tft.height() - 40, ILI9341_BLACK); // ‡§¨‡•Ä‡§ö ‡§ï‡§æ ‡§è‡§∞‡§ø‡§Ø‡§æ ‡§∏‡§æ‡§´‡§º ‡§ï‡§∞‡•á‡§Ç
    tft.setTextSize(4);
    tft.setCursor(tft.width() / 2 - 100, 100);

    if (lockState == "LOCKED") {
        tft.setTextColor(ILI9341_RED);
        tft.print("LOCKED");
    } else if (lockState == "UNLOCKED") {
        tft.setTextColor(ILI9341_GREEN);
        tft.print("UNLOCKED");
    } else {
        tft.setTextColor(ILI9341_YELLOW);
        tft.print("RUNNING");
    }

    // 2. ‡§ö‡§æ‡§∞‡•ç‡§ú‡§ø‡§Ç‡§ó ‡§Ü‡§á‡§ï‡•â‡§® (Charging/Battery Icon)
    tft.setTextSize(2);
    tft.setTextColor(ILI9341_WHITE);
    tft.setCursor(10, 10);
    tft.print("BT/WIFI OK");
    
    // ‡§¨‡•à‡§ü‡§∞‡•Ä ‡§Ü‡§á‡§ï‡•â‡§® ‡§°‡•ç‡§∞‡§æ ‡§ï‡§∞‡•á‡§Ç (Drawing Battery Icon)
    tft.drawRect(tft.width() - 40, 5, 30, 20, ILI9341_WHITE); // ‡§¨‡•à‡§ü‡§∞‡•Ä ‡§ï‡§æ ‡§¨‡§æ‡§π‡§∞‡•Ä ‡§π‡§ø‡§∏‡•ç‡§∏‡§æ
    tft.fillRect(tft.width() - 10, 10, 5, 10, ILI9341_WHITE);  // ‡§¨‡•à‡§ü‡§∞‡•Ä ‡§ï‡§æ ‡§õ‡•ã‡§ü‡§æ ‡§ü‡•â‡§™
    
    // ‡§ö‡§æ‡§∞‡•ç‡§ú‡§ø‡§Ç‡§ó ‡§∏‡•ç‡§ü‡•á‡§ü‡§∏
    if (isCharging) {
        tft.fillRect(tft.width() - 38, 7, 26, 16, ILI9341_YELLOW); // ‡§ö‡§æ‡§∞‡•ç‡§ú‡§ø‡§Ç‡§ó ‡§π‡•ã‡§®‡•á ‡§™‡§∞ ‡§™‡•Ä‡§≤‡§æ
        tft.setCursor(tft.width() - 35, 30);
        tft.setTextColor(ILI9341_YELLOW);
        tft.print("CHARGING");
    } else {
        // ‡§Ø‡§π‡§æ‡§Å ‡§¨‡•à‡§ü‡§∞‡•Ä ‡§≤‡•á‡§µ‡§≤ (‡§∏‡§ø‡§∞‡•ç‡§´‡§º ‡§¶‡§ø‡§ñ‡§æ‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è 80%)
        tft.fillRect(tft.width() - 38, 7, 20, 16, ILI9341_GREEN); // 80% ‡§π‡§∞‡•Ä ‡§¨‡•à‡§ü‡§∞‡•Ä
        tft.setCursor(tft.width() - 35, 30);
        tft.setTextColor(ILI9341_GREEN);
        tft.print("80%");
    }
    
    // 3. ‡§ü‡§æ‡§á‡§Æ ‡§°‡§ø‡§∏‡•ç‡§™‡•ç‡§≤‡•á (Time Display - Clock) - ‡§Ö‡§¨ local variables ‡§á‡§∏‡•ç‡§§‡•á‡§Æ‡§æ‡§≤ ‡§ï‡§∞ ‡§∞‡§π‡§æ ‡§π‡•à
    tft.setTextSize(2);
    tft.setTextColor(ILI9341_CYAN);
    tft.setCursor(tft.width() / 2 - 40, 10);
    tft.printf("%02d:%02d:%02d", currentHour, currentMinute, currentSecond); 
    
    lastTFTUpdate = millis();
}
// -----------------------------------------------------------------


// ---------------- Setup -----------------
void setup(){
  Serial.begin(115200);
  
  // üî• TFT ‡§∂‡•Å‡§∞‡•Ç ‡§ï‡§∞‡•á‡§Ç
  tft.begin();
  tft.setRotation(3); // ‡§∞‡•ã‡§ü‡•á‡§∂‡§® ‡§∏‡•á‡§ü ‡§ï‡§∞‡•á‡§Ç (‡§≤‡•à‡§Ç‡§°‡§∏‡•ç‡§ï‡•á‡§™ ‡§Æ‡•ã‡§°)
  tft.fillScreen(ILI9341_BLACK);
  tft.setTextSize(2);
  tft.setTextColor(ILI9341_WHITE);
  tft.println("SMART LOCK STARTING...");

  // üî• SD ‡§ï‡§æ‡§∞‡•ç‡§° ‡§∂‡•Å‡§∞‡•Ç ‡§ï‡§∞‡•á‡§Ç (‡§¨‡§ø‡§®‡§æ SD ‡§ï‡§æ‡§∞‡•ç‡§° ‡§ï‡•á ‡§≠‡•Ä ‡§ö‡§≤‡•á‡§ó‡§æ)
  if (!SD.begin(SD_CS)) {
    Serial.println("SD Card not found (OK)");
    tft.setTextColor(ILI9341_YELLOW);
    tft.println("SD Card: NOT FOUND");
  } else {
    Serial.println("SD Card found!");
    tft.setTextColor(ILI9341_GREEN);
    tft.println("SD Card: READY");
    // SD ‡§ï‡§æ‡§∞‡•ç‡§° ‡§∏‡•á ‡§≤‡•â‡§ï ‡§°‡•á‡§ü‡§æ ‡§≤‡•ã‡§° ‡§ï‡§∞‡§®‡•á ‡§ï‡§æ ‡§ï‡•ã‡§° ‡§Ø‡§π‡§æ‡§Å ‡§ú‡•ã‡§°‡§º ‡§∏‡§ï‡§§‡•á ‡§π‡•ã
  }

  // pins
  pinMode(MOTOR_IN1,OUTPUT);
  pinMode(MOTOR_IN2,OUTPUT);
  pinMode(LED_FORWARD,OUTPUT);
  pinMode(LED_BACKWARD,OUTPUT);
  pinMode(LED_SLEEP,OUTPUT);
  pinMode(LED_CHARGING,OUTPUT);
  pinMode(LOCK_BUTTON,INPUT_PULLUP);
  pinMode(UNLOCK_BUTTON,INPUT_PULLUP);
  pinMode(BUZZER_PIN,OUTPUT);
  pinMode(CHARGING_PIN,INPUT);

  EEPROM.begin(EEPROM_SIZE);
  
  // load lock state
  byte saved = EEPROM.read(EEPROM_ADDR_LOCK_STATE);
  lockState = (saved==1)?"LOCKED":"UNLOCKED";

  // load motor time if saved
  EEPROM.get(EEPROM_ADDR_MOTOR_TIME,MOTOR_RUN_TIME);

  // üî• ‡§Æ‡•ã‡§ü‡§∞ ‡§ï‡•Ä ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§π‡§≤ ‡§ï‡§∞‡§®‡•á ‡§µ‡§æ‡§≤‡§æ ‡§ö‡•á‡§ï
  if (MOTOR_RUN_TIME < 1000 || MOTOR_RUN_TIME > 60000) { 
      MOTOR_RUN_TIME = 8000;
      EEPROM.put(EEPROM_ADDR_MOTOR_TIME, MOTOR_RUN_TIME);
      EEPROM.commit();
  }

  // Bluetooth
  SerialBT.begin("SECURITY DOOR LOCK");
  beepBuzzer(2);

  // WiFi AP
  WiFi.softAP(ssid,wifiPassword);
  delay(250);
  Serial.print("Hotspot IP: "); Serial.println(WiFi.softAPIP());

  // Web server
  server.on("/",handleRoot);
  server.on("/lock",handleLock);
  server.on("/unlock",handleUnlock);
  server.on("/system_on",handleSystemOn);
  server.on("/system_off",handleSystemOff);
  server.begin();

  lastActivityTime=millis();

  // üî• ‡§®‡§Ø‡§æ ‡§ü‡§æ‡§á‡§Æ ‡§∏‡•á‡§ü-‡§Ö‡§™: ‡§Ö‡§¨ ‡§Ø‡§π ‡§∏‡§ø‡§∞‡•ç‡§´‡§º millis() ‡§™‡§∞ ‡§ö‡§≤‡•á‡§ó‡§æ
  lastSecond = millis(); 
  // setTime(10, 0, 0, 1, 1, 2025); // <--- TimeLib ‡§ï‡•Ä ‡§≤‡§æ‡§á‡§® ‡§Ö‡§¨ ‡§π‡§ü ‡§ó‡§à ‡§π‡•à
  
  // üî• TFT ‡§ï‡•ã ‡§´‡§æ‡§á‡§®‡§≤ ‡§Ö‡§™‡§°‡•á‡§ü ‡§ï‡§∞‡•á‡§Ç
  updateTFT();
}

// ---------------- Loop -----------------
void loop(){
  checkCharging();
  server.handleClient();

  // üî• TFT ‡§ï‡•ã ‡§Ö‡§™‡§°‡•á‡§ü ‡§ï‡§∞‡§§‡•á ‡§∞‡§π‡•á‡§Ç (‡§á‡§∏‡§Æ‡•á‡§Ç ‡§Ö‡§¨ ‡§ü‡§æ‡§á‡§Æ ‡§≤‡•â‡§ú‡§ø‡§ï ‡§≠‡•Ä ‡§∂‡§æ‡§Æ‡§ø‡§≤ ‡§π‡•à)
  updateTFT(); 

  // Bluetooth commands with PIN/password support
  if(SerialBT.available()){
    lastActivityTime=millis();
    String cmd = SerialBT.readStringUntil('\n'); cmd.trim();
    
    if(cmd.startsWith("LOCK:")){
      String p = cmd.substring(5);
      if(p.equals(String(bluetoothPin)) || p.equals(String(newBluetoothPin))) startMotor(true);
      else beepBuzzer(1);
    } 
    else if(cmd.startsWith("UNLOCK:")){
      String p = cmd.substring(7);
      if(p.equals(String(bluetoothPin)) || p.equals(String(newBluetoothPin))) startMotor(false);
      else beepBuzzer(1);
    } 
    // ... (‡§¨‡§æ‡§ï‡•Ä Bluetooth ‡§ï‡§Æ‡§æ‡§Ç‡§°‡•ç‡§∏ ‡§µ‡•à‡§∏‡•á ‡§π‡•Ä ‡§∞‡§π‡•á‡§Ç‡§ó‡•á) ...
    else if(cmd.startsWith("TIME:")){
      unsigned long t = cmd.substring(5).toInt();
      if(t>=1){ 
        MOTOR_RUN_TIME = t;
        EEPROM.put(EEPROM_ADDR_MOTOR_TIME,MOTOR_RUN_TIME);
        EEPROM.commit();
        SerialBT.println("Motor time updated: "+String(MOTOR_RUN_TIME)+" ms");
        beepBuzzer(1);
      }
    } 
    else if(cmd.startsWith("SET_PIN:")){
      String pins = cmd.substring(8);
      int sep = pins.indexOf(':');
      if(sep>0){
        String oldPin = pins.substring(0,sep);
        String newPin = pins.substring(sep+1);
        if(oldPin.equals(String(bluetoothPin))){
          strncpy(newBluetoothPin,newPin.c_str(),7);
          SerialBT.println("Bluetooth PIN updated");
          beepBuzzer(2);
        } else beepBuzzer(1);
      }
    }
    else if(cmd.startsWith("SET_WIFI_PIN:")){
      String pins = cmd.substring(13);
      int sep = pins.indexOf(':');
      if(sep>0){
        String oldPin = pins.substring(0,sep);
        String newPin = pins.substring(sep+1);
        if(oldPin.equals(String(wifiPassword))){
          strncpy(newWiFiPassword,newPin.c_str(),20);
          WiFi.softAP(ssid,newWiFiPassword);
          SerialBT.println("WiFi PIN updated");
          beepBuzzer(2);
        } else beepBuzzer(1);
      }
    }
    else beepBuzzer(1);
  }

  // Physical buttons
  int lockBtn=digitalRead(LOCK_BUTTON);
  int unlockBtn=digitalRead(UNLOCK_BUTTON);
  if(lockBtn==LOW && lastLockState==HIGH && !isMotorRunning) startMotor(true);
  if(unlockBtn==LOW && lastUnlockState==HIGH && !isMotorRunning) startMotor(false);
  lastLockState=lockBtn;
  lastUnlockState=unlockBtn;

  // Motor auto stop
  if(isMotorRunning && (millis()-motorStartMillis>=MOTOR_RUN_TIME)) stopMotor();

  // Sleep timeout
  if(!isSleepMode && (millis()-lastActivityTime>SLEEP_TIMEOUT)){
    isSleepMode=true;
    digitalWrite(LED_SLEEP,HIGH);
    SerialBT.end();
    WiFi.softAPdisconnect(true);
  }

  updateSleepLED();
  delay(20);
}